# 이벤트 
목차
- 이벤트 드리븐 프로그래밍
- 이벤트 타입
- 이벤트 핸들러 등록 
- 이벤트 핸들러 제거
- 이벤트 객체 
---
### 이벤트 드리븐 프로그래밍
웹이 특정 타입의 이벤트에 대해 반응해서 어떤 일을 하고 싶다면
해당하는 그 타입의 이벤트가 발생했을 때 호출될 함수를 브라우저에게 알려 호출을 위임한다. 

#### 이벤트 핸들러(이벤트 리스너)
- 이벤트가 발생했을 때 호출될 함수 
- 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 걸 <b>이벤트 핸들러 등록</b>이라고 한다.

예를 들어
- 유저가 버튼을 클릭했을 떄 특정 함수를 호출해서 처리하고 싶다고 가정 
- "언제 함수를 호출해야하는가?" 가 문제임 
- 유저가 언제 버튼을 클릭할지 알 수 없으므로 브라우저는 버튼 클릭을 감지하여 클릭 이벤트를 발생
- 클릭이벤트가 발생하면 특정 함수 (이벤트 핸들러)를 호출하도록 브라우저에게 시킴(위임, 이벤트 핸들러 등록)
- 즉, 언제 함수 호출할지 모르므로 개발자가 명시하는게 아니라 브라우저에게 함수 호출을 위임하는 것.

---
#### 이벤트 타입
 이벤트 종류를 나타내는 문자열로 약 200가지 종류가 있다.
- 마우스 이벤트
- 키보드 이벤트
- 포커스 이벤트 
- 폼 이벤트
- 값 변경 이벤트
- DOM 뮤테이션 이벤트
- 뷰 이벤트
- 리소스 이벤트 

--- 
### 이벤트 핸들러 등록
이벤트 발생 시 브라우저에게 이벤트 핸들러의 호출을 위임하는 것.
이벤트 핸들러를 등록하는 방법은 3가지가 있다.
- 이벤트 핸들러 어트리뷰트 방식
- 이벤트 핸들러 프로퍼티 방식
- addEventListener 메서드 방식

---
#### 1. 이벤트 핸들러 어트리뷰트 방식

```js
<!DOCTYPE html>
<html>
<body>
    <button onclick="sayHi('Lee')">click me</button>
    <script>
        function sayHi(name) {
            console.log(`Hi! ${name}.`);
        }
    </script>
</body>
</html>
```
- HTML 요소의 어트리뷰트 중에 이벤트 핸들러 어트리뷰트가 있다.
- on 접두사 + 이벤트 타입 (onclick = on + click) 으로 나타낸다.
- 어트리뷰트의 값으로 함수 호출문 등의 문을 할당하면 등록된다.
- 여기서는 sayHi() 라는 참조문이 아닌 함수 호출문 할당하였지만
- <i>뒤에서 살펴볼 프로퍼티 방식에서는 함수 참조문을 할당한다.</i>

이벤트 핸들러를 등록 할 때, 함수 호출문을 등록하면 함수 호출문의 평가 결과인 값이 등록되므로 함수 참조를 할당해주는 것이 맞다.  
하지만 위에서는 함수 호출문을 할당했는데, 이는
<b>이벤트 핸들러 어트리뷰트 값은 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.</b>
`"onclick="sayHi('Lee')"` 어트리뷰트는 파싱되어 
```js
<!-- 함수 몸체 -->
fucntion onclick(event){
    sayHi('Lee');
}
```
와 같은 함수를 만들고, 어트리뷰트 이름인 onclick과 동일한 키에 할당한다.

## 동일한 키에 넣었다는 사진 등록하기


(이벤트 핸들러 어트리뷰트와 이벤트 핸들러 프로퍼티)

- HTML과 자바스크립트는 분리하는 것이 좋아 어트리뷰트 방식은 사용을 지양하며 오래된 코드에서나 볼 수 있다.
- 하지만 Angular,React,Svelte,Vue.js 같은 CBD(구성요소기반) 방식의 프레임워크에서는 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리한다.
- CBD에서는 HTML,CSS,JS를 개별적인 요소가 아닌 뷰를 구성하기 위한 구성 요소로 보기 때문이다.

```js
// 앵귤러
<button (click)="handleClick($event)">Save</button> 

//리액트
<button onClick={handleClick}>Save</button> 
```
---
### 2. 이벤트 핸들러 프로퍼티 방식
- 프로퍼티 키 역시 onclick과 같이 ( on + 이벤트 타입 ) 의 형식이다.
- 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 등록 완료된다. 
```js
<body>
    <button>click me! </button>
    <script>
    // document.querySelector(선택자),jQuery 문법으로 첫번째로 일치하는 요소에 대한 결과만 반환
        const $button = document.querySelector('button');

        // 프로퍼티에 이벤트 핸들러(함수)를 바인딩
        // $button : 이벤트 타깃(이벤트를 발생시킬 객체)
        // onclick : 이벤트 종류를 나타내는 문자열
        // function () : 이벤트 핸들러 
        $button.onclick = function () {
            console.log('버튼 클릭');
        }
    </script>
</body>
```
버튼 요소가 클릭되면 handleClick 함수를 호출하도록 등록하는 경우<br>
이벤트 타깃은 버튼 요소, 이벤트 타입은 click, 이벤트 핸들러는 handleClick 함수이다.

- 이벤트 타깃인 버튼 요소에 함수를 바인딩 한 것 처럼 대부분은 이벤트 핸들러를 이벤트 타깃에 바인딩한다.
- 하지만 반드시 그래야 하는 것은 아니며,
- 이벤트 핸들러는 이벤트 타킷 또는 '전파된 이벤트를 캐치할 DOM 노드 객체'에도 바인딩한다.
- "이벤트 전파", "이벤트 위임" 참고 

- 앞에서 본 어트리뷰트 방식도 결국엔 DOM 노드 객체의 이벤트 프로퍼티로 변환됐었으므로 결과적으로는 프로퍼티 방식과 동일하다고 할 수 있다. 
- 하지만 프로퍼티 방식은 어트리뷰트 방식과 다르게 HTML과 JS가 섞이는 문제를 해결한다.
- 프로퍼티의 방식의 단점은 이벤트 핸들러 프로퍼티 하나당 하나의 핸들러만 바인딩이 가능하다는 점이다.
```js
<body>
    <button>click me! </button>
    <script>

        const $button = document.querySelector('button');

        // 첫 번째로 바인딩된 핸들러는 
        $button.onclick = function () {
            console.log('버튼 클릭 1번');
        }

        // 두번쨰로 바인딩 된 함수가 재할당되어서 실행되지 않습니다.
        $button.onclick = function () {
            console.log('버튼 클릭 2번');
        }
    </script>
</body>
```

---
### 3. addEventListener 방식

- 새로 도입된 `EventTarget.prototype.addEventListener ` 메서드를 사용해 이벤트를 등록하는 방식(DOM Level 2에서 도입)
- 어트리뷰트 방식과 프로퍼티 방식은 DOM level 0부터 제공되던 방식

## 에드이벤트리스너 구조 사진 넣기 pic1

- 첫번째 매개변수 : 이벤트 종류인 이벤트 타입 전달, 이때 프로퍼티 방식과 다르게 접두사 on을 붙이지 않는다.
- 두번째 매개변수 : 이벤트 핸들러를 전달
- 마지막 매개변수 : 이벤트를 캐치할 이벤트 전파 단계를 지정.(캡처링 or 버블링) , 생략하거나 false면 버블링 단계에서 이벤트를 캐치하고, true라면 캡처링 단계에서 이벤트를 캐치 ("이벤트 전파" 참고)

```js
<body>
    <button>click me! </button>
    <script>
        const $button = document.querySelector('button');

        // 이벤트 핸들러 프로퍼티 방식
        // $button.onclick = function () {
        //     console.log('버튼 클릭!');
        // }

        // addEventListener 방식
        $button.addEventListener('click', function () {
            console.log('버튼 클릭!');
        });        
    </script>
</body>
```

- 프로퍼티 방식에선 프로퍼티에 이벤트 핸들러(함수)를 바인딩했지만
- addEventListener 메서드에는 이벤트 핸들러를 인수로 전달한다.

동일한 HTML 요소에서 프로퍼티 방식과 addEventListener 방식을 모두 이용한다면 
```js
<body>
    <button>click me! </button>
    <script>
        const $button = document.querySelector('button');

        // 이벤트 핸들러 프로퍼티 방식
        $button.onclick = function () {
            console.log('[프로퍼티 방식]버튼 클릭!');
        }

        // addEventListener 방식
        $button.addEventListener('click', function () {
            console.log('[에드이벤트리스너 방식]버튼 클릭!');
        });        
    </script>
</body>
```

## pic2 넣기

addEventListener 방식은 하나 이상의 이벤트 핸들러를 등록할 수 있다. 이벤트 핸들러는 등록된 순서대로 호출된다.


```js
<body>
    <button>click me! </button>
    <script>
        const $button = document.querySelector('button');

        // addEventListener 방식
        $button.addEventListener('click', function () {
            console.log('첫번째로 등록한 핸들러');
        });   
        
        $button.addEventListener('click', function () {
            console.log('두번째로 등록한 핸들러');
        });  
    </script>
</body>
```

### 결과 사진 넣기 pic3

---
### 이벤트 핸들러 제거
- `EventTarget.prototype.removeEventListener` 메서드 사용
- 단, addEventListener에서 전달한 인수와 동일해야 제거가 처리된다.
```js
<body>
    <button>click me! </button>
    <script>
        const $button = document.querySelector('button');

        const handleClick = () => console.log('버튼 클릭!!')

        // 이벤트 핸들러 등록
        $button.addEventListener("click",handleClick);
        
        // 이벤트 핸들러 제거
        $button.removeEventListener("click",handleClick, true); // 제거 실패
        $button.removeEventListener("click",handleClick); // 제거 성공
    </script>
</body>
```

- 또한 익명함수로 이벤트 핸들러를 등록한 경우, 등록한 이벤트 핸들러를 참조해서 제거해야하는데 익명함수이기 때문에 제거할 수 없다.
- 위와 같이 이벤트 핸들러의 참조를 변수나 자료구조에 저장해야한다.
```js
    $button.addEventListener("click",() => {
        console.log("익명함수 참조실패ㅠ"));
    });
```

단, 기명 이벤트 핸들러 내부에서 `removeEventListener`로 제거가 가능하다. 이 때, 이벤트 핸들러는 <b>단 한번만</b> 호출된다. 
- 버튼 요소를 여러번 클릭해도 한번만 호출됨.
```js
<body>
    <button>click me! </button>
    <script>
        const $button = document.querySelector('button');

        // 기명 함수를 이벤트 핸들러로 등록
        $button.addEventListener('click', function foo() {
            console.log("기명함수 등록");

            // 기명 함수 내부에서 핸들러 제거, 따라서 핸들러는 한번만 호출됨
            $button.removeEventListener('click', foo);
        })
    </script>
</body>
```

만약 기명함수를 핸들러로 등록할 수 없다면, 익명함수로 등록하고 함수 자신을 가리키는 
`arguments.callee`를 이용한다.
- `arguments.callee`는 코드 최적화를 방해하므로 strict mode에서 사용이 금지된다.
- 가급적으로 이벤트 핸들러 제거는 변수나 자료구조에 저장해서 제거하도록 하자.

```js
<body>
    <button>click me! </button>
    <script>
        const $button = document.querySelector('button');

        // 무명 함수를 이벤트 핸들러로 등록
        $button.addEventListener('click', function () {
            console.log("무명함수 등록");

            // 이벤트 핸들러 제거. 단 한번만 호출
            // arguments.callee는 호출된 함수인 자기 자신
            $button.removeEventListener('click', arguments.callee);
        })
    </script>
</body>
```


이벤트 핸들러 프로퍼티 방식으로 등록한 핸들러를 제거하려면 프로퍼리에 `null`을 할당한다.

```js
<body>
    <button>click me!</button>
    <script>
        const $button = document.querySelector('button');

        const handleClick = () => console.log("버튼 클릭");

        // 프로퍼티 방식으로 등록
        $button.onclick = handleClick;

        // removeEventListener으로 제거할 수 없음.
        $button.removeEventListener('click',handleClick);

        // 프로퍼티에 null을 할당하면 제거 가능
        $button.onclick = null;
    </script>
</body>
```
요약
- 이벤트 핸들러 제거는 `removeEventListener` 메서드를 사용
- 제거할 때, 인수의 형태는 등록할 때랑 같아야 한다.
- 무명함수일때는 이벤트 리스너 자리에 `arguments.callee`를 사용해서 제거한다.
- 가장 바람직한 제거는 이벤트 핸들러를 변수에 저장해서 제거하는 모습이다.
- 프로퍼티 방식으로 등록한 이벤트 리스너는 `removeEventListener` 로 제거할 수 없다.

---
## 이벤트 객체
