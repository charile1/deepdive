## 함수 
***
목차
- 12.1 함수란?
- 12.2 함수를 사용하는 이유
- 12.3 함수 리터럴
- 12.4 함수 정의
- 12.5 함수 호출
- 12.6 참조에 의한 전달과 외부 상태의 변경
- 12.7 다양한 함수의 형태
---
### 12.1 함수란?
수학에서 함수는 "입력(input)을 입력 받아 출력(output)을 내보내는 과정"
`f(x,y) = x + y` 를 자바스크립트 함수로 표현해보자.
```js
// f(x,y) = x + y
function add(x, y) {
    retunrn x + y;
}
// f(2, 5) = 7
add(2, 5); //7
```
프로그래밍 언어에서 함수는 
>일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 <br> 하나의 실행 단위로 정의한 것.
- 매개변수(파라미터): 함수 내부로 입력을 전달받는 변수
- 인수(아규먼트) : 입력
- 반환값(리턴값) : 출력 

```js
function add(x, y) {
    return x + y;
}
```
- add = 함수이름 
- (x, y) = 매개변수
- x + y = 반환값 

는 함수 정의 부분이다.<br>
함수를 정의하는 방법은 다양하다. 여기서는 함수 선언문으로 정의하였다. 

```js 
add(2, 5);
```
- (2, 5) = 인수 <br>

는 함수 호출 부분이다. 
함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고, 반환값을 반환한다.

### 12.2 함수를 사용하는 이유 

코드의 재사용
- 실행 시점을 개발자가 결정하여 몇 번이든 재사용이 가능하다. 
- 유지보수의 편의성 , 코드의 신뢰성 
- 함수는 객체 타입의 값이므로 이름을 붙일 수 있다. 적절한 이름은 코드의 가독성 향상을 돕는다. 

### 12.3 함수 리터럴 
함수도 함수 리터럴로 생성할 수 있다. <br> 함수 리터럴은 구성요소는 다음과 같다.
- fuction 키워드
- 함수 이름
- 매개변수 목록 
- 함수 몸체 

함수 이름
- 함수 이름은 식별자로서 네이밍 규칙을 준수한다.
- 함수 이름은 몸체 내에서만 참조가 가능하다.  
- 함수 이름은 생략 가능하며 익명 함수라 한다.

매개변수 목록
- 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.
- 함수 호출시,매개변수의 순서대로 인수가 할당된다. 
- 매개변수는 함수 내에서 변수로 취급되므로 식별자 네이밍 규칙을 준수한다.

함수 몸체 
- 함수 호출 시에 실행될 문들을 실행 단위로 정의한 코드 블록이다. 
- 함수 몸체는 함수 호출에 의해 실행된다. 
 
```js
// 변수에 함수 리터럴을 할당한 모습
var a = function 함수이름 (매개변수) {
    함수 몸체;
};
```
리터럴은 값을 생성하기 위한 표기법이다. 함수 리터럴로 평가되어 값을 생성하며, 이 값은 객체다. `즉, 함수는 객체다.`

그러나 함수는 객체지만 일반 객체와 다르다. <b>일반 객체는 호출할 수 없지만 함수는 호출이 가능하다.</b> 그리고 함수 객체만의 고유한 프로퍼티를 갖는다. 

---

### 12.4 함수 정의
함수 정의 방식 4가지 
- 함수 선언문 (표현식이 아닌 문)
```js
function add(x, y) {
    return x + y;
}
```
- 함수 표현식 (표현식인 문)
```js
let add = function (x, y){
    return x + y;
}
```
- Function 생성자 함수
```js
let add = new Function('x', 'y', 'return x + y');
```
- 화살표 함수
```js
let add = (x, y) => x + y;
```
```js
// 함수 표현식, 생성자 함수, 화살표 함수에선 익명함수로 쓰고, 변수명에다가 함수명을 대신 써주는 모습을 볼 수 있었다. 
```
** 변수 선언과 함수 정의 **<br>
변수는 '선언'한다고 했지만 함수는 '정의'한다고 표현했다. 함수 선언문이 평가되면서 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.

### 12.4.1 함수 선언문
```js
function add(x, y) {
    return x + y;
}

// 함수 참조
// console.dir은 함수 객체의 프로퍼티까지 출력한다. 
console.dir(add); // ƒ add(x, y)

// 함수 호출
console.log(add(1, 6)); //7
```
보다시피 `console.dir`과 `console.log`를 `add` 라는 함수 이름으로 호출하였다. 함수 선언문은 함수 이름을 생략할 수 없다. 
함수 선언문은 표현식이 아닌 문이다. 콘솔에서 함수 선언문을 실행하면 완료 값 undefined가 출력된다. <br> 함수 선언문은 표현식이 아니므로 변수에 할당할 수 없다. 
```js
let add = function(x, y){
    return x + y;
};

console.log(add(2, 5));
```
하지만 위의 예제를 보면 add 라는 변수에 함수를 할당하고 있다. 위가 가능한 이유는 자바스크립트 엔진이 동일한 함수 리터럴을을 표현식이 아닌 함수 선언문으로 해석하는 경우도 있고 표현식인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다. 

>중의적 표현으로 예시를 들면 <br>
{ } 중괄호는 블록문일수도 있고 객체 리터럴일 수도 있다. 이는 코드의 문맥에 따라 해석이 달라진다. 단독으로 존재하면 블록문으로 해석하고 할당연산자의 우변에 있어서 피연산자로 사용되면 객체 리터럴로 해석한다. 

`기명 함수 리터럴` 도 중의적 표현이다. 코드의 문맥에 따라 해석이 달라진다. 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 `함수 선언문`으로 해석하고, 함수 리터럴이 값으로 평가되어야하는 문맥 ( 변수에 할당하거나 피연산자로 사용하는 경우)에서는 `함수 리터럴 표현식`으로 해석한다. 

```js
// 기명 함수 리터럴을 단독 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에선 익명 함수를 쓸 수 없기 때문이다.

function foo() { console.log('hello')} //undefined
foo(); // hello

// 함수 리터럴을 피연산자로 사용하면 함수 리터럴 표현식으로 해석된다. (값으로)
// 함수 리터럴에선 이름 생략이 가능하다.
( function bar() { console.log('hello'); });
bar(); //ReferenceError
```

그룹 연산자 ( ) 내에 있는 피연산자는 값으로 평가될 수 있는 표현식이어야한다. 따라서 함수 bar는 함수 리터럴 표현식으로 해석된다. <br>
함수 선언문과 함수 리터럴 표현식은 호출 방식에서도 차이가 있다. 함수 표현식을 보면서 어떤 차이인지 알아보자! 

함수 리터럴의 함수 몸체 부분에서 `'함수 이름은 몸체 내에서만 참조가 가능하다.'` 라는 내용도 함수 선언식과 함수 표현식의 차이에서 드러난다. 
- 자바스크립트는 함수 선언문을 해석해 함수 객체를 생성
-  함수 이름은 함수 몸체 내부 에서만 유효한 식별자. 
- 함수 호출을 위해서 별도로 함수 객체를 가리키는 식별자를 생성.
- 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당.
```js
// 함수를 호출한 add는 함수명의 add가 아니라 식별자 add 인 것.
var add = function add(x, y) {
    return x + y;
}
console.log(add(2, 5);)
```
### 12.4.2 함수 표현식

자바스크립트의 함수는
- 값처럼 변수로 할당도 가능하고 프로퍼티의 값도 될수 있고 배열의 요소도 될 수 있다.
- 이처럼의 값을 성질을 갖는 객체를 `일급 객체`라고 한다. 
- <b>자바스크립트의 함수는 일급 객체다.</b> 
- 이것은 함수를 값처럼 자유롭게 사용할 수 있다는 뜻이다. 
```js
// 호이스팅이 가능한 함수 선언문 
console.log(foo(2,5));

function foo(x, y) {
    return x + y;
}
// 7
// undefined

// 호이스팅이 불가능한 함수 표현식
console.log(bar(2,5));

let bar = function (x, y) {
    return x - y;
}
// Uncaught ReferenceError: bar is not defined
//     at <anonymous>:1:13
```
함수 선언문의 경우, 런타임 이전에 자바스크립트 엔진에 의해서
- 함수 객체 생성
- 엔진이 함수명과 동일한 식별자를 생성
- 식별자에 함수 객체 할당<br>

의 과정들이 실행된다.
그래서 함수 선언문 이전에 함수를 참조할 수 있고 호출할 수 있는 것이다. 

함수 표현식의 경우, ( 변수 선언문 ) + ( 변수 할당문 )의 축약 표현 
- 함수 표현식은 함수 호이스팅이 아니라 `변수 호이스팅` 발생
- 변수 선언은 런타임 이전에 undefined로 초기화됨
- 따라서 함수 호출 시, undefined 를 호출하는 것과 마찬가지.

### 12.4.4 Function 생성자 함수
** 생성자 함수란? **
- 객체를 생성하는 함수
```js
var add = new Function('x', 'y', return x + y);

console.log(add(2, 5));
```
- Function 생성자 함수로 생성하는 것은 클로저를 생성하지 않는 등 일반적으로 쓰이지도 않고 바람직하지도 않다.

### 12.4.5 화살표 함수
- function 키워드 대신 `=>` 를 사용한다
- 항상 익명 함수로 정의한다.
- 기존 함수와 this 바인딩 방식이 다르다.
- 프로토타입 프로퍼티가 없다.
- argument 객체를 생성하지 않는다.
- (26장에 다시 나온다.)

```js
const add = (x, y) => x + y;

console.log(add(2, 5));
```

### 12.5 함수 호출
매개변수는 함수 몸체 내부에서만 참조 가능하고 외부에서는 참조할 수 없다. 
매개변수의 스코프(유효 범위)는 함수 내부다.
```js
// console문을 return문보다 위에 써준 이유는 return문은 함수의 실행을 중단하고 함수 몸체를 빠져 나가서 console문을 무시하기 때문이다.
function add(x, y) {
    console.log(x, y); // 2 5
    return x + y ; // 7
}
add(2, 5);

// add 함수의 매개변수는 함수 내부에서만 참조할 수 있다.
console.log(x, y);
// ReferenceError: x is not defined
```

함수는 매개변수의 개수와 인수의 개수가 일치하지 않아도 된다. 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined 이다. 

```js
function add(x, y) {
    return x + y ; // 2 + undefined
}
    console.log(add(2)); //NaN
```
```js
// 초과된 인수는 무시되고 7은 버리는게 아니라 arguments 객체의 프로퍼티로 보관된다.
function add(x, y) {
    return x + y ; 
}
    console.log(add(2, 5, 7)); //7
```

- 자바스크립트는 동적 언어이므로 매개변수의 타입을 사전에 정의할 수 없다. 따라서 적절한 인수가 전달되었는지 확인할 필요가 있다. 
```js
// 매개변수를 통해 전달된 인수의 타입이 넘버가 아닌 경우 에러 발생
function add(x, y) {
    if (typeof x !== 'number' || typeof y !== 'number') {
    throw new TypeError('인수는 모두 숫자값으로 해주세요');
}
return x + y;
}
console.log(add(2, 5)); //7
console.log(add('a', 'b')); // TypeError: 인수는 모두 숫자값으로 해주세요.
```
- 적절한 인수인지 확인은 가능하나 사전에 방지는 할수 없다.
- 타입스크립트와 같은 정적 언어를 도입해 컴파일 시점에 방지할 수 있게 할 수 있다. 
- arguments 객체를 통해 인수 개수를 확인할 수도 있다.
- 인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당할 수도 있다. 
- 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.
```js
// 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화한다.
// 기본값은 매개변수에 인수를 전달하지 않은 경우와, undefined를 전달한 경우에만 유효하다.
function add(a, b, c) {
    a = a || 0;
    b = b || 0;
    c = c || 0;
    return a + b + c;
}

console.log(add(1 + 2 + 3)); //6
console.log(add(1 + 2 )); // 3
console.log(add(1)); //1
console.log(add())); //0
```

```js
// 즉시 실햄 함수도 일반 함수처럼 값을 반환할 수 있다.
```











